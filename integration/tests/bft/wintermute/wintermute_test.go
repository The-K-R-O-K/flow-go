package wintermute

import (
	"fmt"
	"testing"
	"time"

	"github.com/stretchr/testify/require"
	"github.com/stretchr/testify/suite"

	"github.com/onflow/flow-go/model/flow"
)

// wintermuteTimeout corresponds to the timeout the wintermute orchestrator have to conduct the attack.
const wintermuteTimeout = 2 * time.Minute

type WintermuteTestSuite struct {
	Suite
}

func TestWintermuteAttackTestSuite(t *testing.T) {
	suite.Run(t, new(WintermuteTestSuite))
}

// TestWintermuteAttack is passing upon a successful wintermute attack is conducted, i.e., wintermute attack orchestrator corrupting an execution
// result, and then orchestrating its corrupt verification nodes to verify it. The test passes if enough result approvals for corrupt chunks
// are witnessed in the test network, as well as the block corresponding to the corrupt execution result is sealed.
func (w *WintermuteTestSuite) TestWintermuteAttack() {

	corruptResult := w.waitForExecutionResultCorruption()
	victimBlock := w.BlockState.WaitForBlockById(w.T(), corruptResult.BlockID)

	// waits for the execution receipt of victim block from both CORRUPT execution nodes.
	receiptB1 := w.ReceiptState.WaitForReceiptFrom(w.T(), victimBlock.Header.ID(), w.corruptEN1Id)
	w.T().Logf("receipt for victim block generated by execution node-1: %x result ID: %x\n", w.corruptEN1Id, receiptB1.ExecutionResult.ID())
	receiptB2 := w.ReceiptState.WaitForReceiptFrom(w.T(), victimBlock.Header.ID(), w.corruptEN2Id)
	w.T().Logf("receipt for victim block generated by execution node-2: %x result ID: %x\n", w.corruptEN2Id, receiptB2.ExecutionResult.ID())

	// makes sure corrupt execution nodes generated the corrupt result for this victim block.
	require.Equal(w.T(), receiptB1.ExecutionResult.ID(), corruptResult.ID())
	require.Equal(w.T(), receiptB2.ExecutionResult.ID(), corruptResult.ID())

	// waits for at least 2 approvals for all chunks of corrupt result from corrupt verification nodes.
	for i := 0; i < len(corruptResult.Chunks); i++ {
		w.ApprovalState.WaitForTotalApprovalsFrom(w.T(),
			w.corruptVnIds,
			corruptResult.ID(),
			uint64(i),
			2)
	}

	// waits until we seal a height equal to the victim block height
	w.BlockState.WaitForSealed(w.T(), victimBlock.Header.Height)
	// then checks querying victim block by height returns the original victim block.
	blockByHeight, ok := w.BlockState.FinalizedHeight(victimBlock.Header.Height)
	require.True(w.T(), ok)
	require.Equal(w.T(), blockByHeight.Header.ID(), victimBlock.Header.ID())
}

// waitForExecutionResultCorruption waits within a timeout till wintermute orchestrator corrupts an execution result.
// It returns the corrupt execution result by wintermute orchestrator.
func (w *WintermuteTestSuite) waitForExecutionResultCorruption() *flow.ExecutionResult {
	var corruptResult *flow.ExecutionResult

	require.Eventually(w.T(), func() bool {
		corrupt, original, conducted := w.Orchestrator.AttackState()
		if !conducted {
			w.T().Logf("pending wintermute orchestrator to conduct attack")
			return false
		}

		corruptResult = &corrupt

		w.T().Logf("wintermute orchesterator conducted corruption, original result: %x, corrupt result: %x", original.ID(), corrupt.ID())
		return true
	}, wintermuteTimeout, 100*time.Millisecond,
		fmt.Sprintf("orchestrator could not conduct execution result corruption within %v seconds", wintermuteTimeout))

	return corruptResult
}
