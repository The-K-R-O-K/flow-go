package common

import (
	"context"
	"testing"

	"github.com/stretchr/testify/require"

	sdk "github.com/onflow/flow-go-sdk"

	"github.com/onflow/flow-go/integration/testnet"
	"github.com/onflow/flow-go/integration/tests/lib"
	"github.com/onflow/flow-go/model/flow"
)

// SealingAndVerificationHappyPathTest evaluates the health of the happy path of verification and sealing. It
// deploys a transaction into the testnet hence causing an execution result with more than
// one chunk, assigns all chunks to the same list of verification nodes in this testnet, and then verifies whether all verification nodes
// generate a result approval for all chunks of that execution result.
// It also enables sealing based on result approvals and verifies whether the block of that specific multi-chunk execution result is sealed
// affected by the emitted result approvals.
//
// It returns the execution receipts and result approvals that are involved in this test.
func SealingAndVerificationHappyPathTest(
	t *testing.T,
	blockState *lib.BlockState,
	receiptState *lib.ReceiptState,
	approvalState *lib.ResultApprovalState,
	accessClient *testnet.Client,
	exeIds flow.IdentifierList,
	verIds flow.IdentifierList,
	rootBlockId flow.Identifier) ([]*flow.ExecutionReceipt, []*flow.ResultApproval) {

	// wait for next height finalized (potentially first height), called blockA, just to make sure consensus progresses.
	currentFinalized := blockState.HighestFinalizedHeight()
	blockA := blockState.WaitForHighestFinalizedProgress(t, currentFinalized)
	t.Logf("blockA generated, height: %v ID: %v\n", blockA.Header.Height, blockA.Header.ID())

	// sends a transaction
	err := accessClient.DeployContract(context.Background(), sdk.Identifier(rootBlockId), lib.CounterContract)
	require.NoError(t, err, "could not deploy counter")

	// waits until for a different state commitment for a finalized block, call that block blockB,
	// which has more than one chunk on its execution result.
	blockB, _ := lib.WaitUntilFinalizedStateCommitmentChanged(t, blockState, receiptState, lib.WithMinimumChunks(2))
	t.Logf("got blockB height %v ID %v\n", blockB.Header.Height, blockB.Header.ID())

	receiptBlocks := make([]*flow.ExecutionReceipt, len(exeIds))
	for i := range exeIds {
		// waits for the execution receipt of blockB from all execution nodes, and makes sure that there is no execution fork.
		receiptBlocks[i] = receiptState.WaitForReceiptFrom(t, blockB.Header.ID(), exeIds[i])
		t.Logf("receipt for blockB generated by execution node-%d: %x result ID: %x\n", i+1, exeIds[i], receiptBlocks[i].ExecutionResult.ID())
	}

	// check for no execution fork
	for i := 0; i < len(receiptBlocks)-1; i++ {
		require.Equal(t, receiptBlocks[i].ExecutionResult.ID(), receiptBlocks[i+1].ExecutionResult.ID(), "execution fork happened at blockB")
	}

	resultB := receiptBlocks[0].ExecutionResult
	resultBId := resultB.ID()

	// re-evaluates that resultB has more than one chunk (system chunk + at least 1 more transaction).
	require.Greater(t, len(resultB.Chunks), 1)
	t.Logf("receipt for blockB generated: result ID: %x with %d chunks\n", resultBId, len(resultB.Chunks))

	// waits till result approval emits for all chunks of resultB
	approvals := make([]*flow.ResultApproval, 0)
	for i := 0; i < len(resultB.Chunks); i++ {
		vnApprovals := approvalState.WaitForTotalApprovalsFrom(t, verIds, resultBId, uint64(i), 1)
		approvals = append(approvals, vnApprovals[0])
	}

	// waits until blockB is sealed by consensus nodes after result approvals for all of its chunks emitted.
	// waits until we seal a height equal to the victim block height
	blockState.WaitForSealed(t, blockB.Header.Height)
	// then checks querying victim block by height returns the victim block itself.
	blockByHeight, ok := blockState.FinalizedHeight(blockB.Header.Height)
	require.True(t, ok)
	require.Equal(t, blockByHeight.Header.ID(), blockB.Header.ID())

	return receiptBlocks, approvals
}
